from portfolio import Portfolio
import engine
from config import config
from logger import create_logger
import multiprocessing as mp
import time
from cli import CommandLineInterface
# Dynamically import the remaining system components
# exec("from feeder.{module} import {module} as DataHandler".format(module=config["components"]["data_handler"]))
# exec("from execution.{module} import {module} as ExecutionHandler".format(module=config["components"]["execution_handler"]))
# exec("from strategy.{module} import {module} as Strategy".format(module=config["components"]["strategy"]))
from feeder.HistoricData import HistoricData as DataHandler
from execution.SimulatedExecutionHandler import SimulatedExecutionHandler as ExecutionHandler
from strategy.MovingAverageCrossover import MovingAverageCrossover as Strategy
import logging
import logging.handlers
import curses


"""
    Project : FincLab

    Author : Peter Lee

Three components of the system are dynamic - it means that you could replace these components in the 'config.ini" file with other classes to override the default:

    strategy : class, default to "MovingAverageCrossover"
        Strategy transforms the data feeds into investment signals, which will be received by the Portfolio class to determine the appropriate order size. Different strategies are available in the strategy folder.

    data_handler : class, default to "HistoricDataHandler"
        DataHandler transforms time series data (or live streams) into periodic "bars" to feed the event-driven system. The "HistoricDataHandler" is suitable for backtesting.

    execution_handler: class, default to "SimulatedExecutionHandler"
        Execution_hanlder executes the orders generated by the Portfolio class. The default "SimulatedExecutionHandler" assumes Interactive Brokers' brokerage fee and ignores market microstructure issues such as slippage, fill ratios etc.
"""

# Initialise environment vars
event_queue = mp.Queue()
log_queue = mp.Queue()
logger = create_logger(log_queue)
jobs = []


def welcome_msgs(log_queue):
    """
    Print initial welcome messages to the UI
    """
    logger.info(r'''[Msg]
FINCLAB Ver 0.1
      _____                  _   _        ____     _          _         ____
     |" ___|      ___       | \ |"|    U /"___|   |"|     U  /"\  u  U | __")u
    U| |_  u     |_"_|     <|  \| |>   \| | u   U | | u    \/ _ \/    \|  _ \/
    \|  _|/       | |      U| |\  |u    | |/__   \| |/__   / ___ \     | |_) |
     |_|        U/| |\u     |_| \_|      \____|   |_____| /_/   \_\    |____/
     )(\\,-  .-,_|___|_,-.  ||   \\,-.  _// \\    //  \\   \\    >>   _|| \\_
    (__)(_/   \_)-' '-(_/   (_")  (_/  (__)(__)  (_")("_) (__)  (__) (__) (__)
　
        Live-Trading / Back-testing Engine
        by Peter Lee (mr.peter.lee@hotmail.com) NOT Copyrighted (2016)
　
Settings
--------
    Initial capital (USD): ${initial_capital:>10}
    Date range: from {start_date:>11} to {today}
    Log level: {level},  Log file enabled ({log_filename}): {save_to_file}
　
System
------
Strategy : {strategy}
　
Data Handler : {data_handler}
    If data does not exist, the app will fetch the list of S&P 500 constituents from Wikipedia [1] and then download corresponding adjusted stock prices from Yahoo! Finance.
        [1]: https://en.wikipedia.org/wiki/List_of_S%26P_500_companies
　
Execution Handler: {execution_handler}
　
Portfolio: Equal Weighted
    Assumes an equal-weighted portfolio in execution and tracks  the portfolio performance using 10-year end-of-day historical data. brokerage fees (interactive brokers) are accounted for in the transaction costs.
        '''.format(
        **config['general'],
        **config['components'],
        **config['data'],
        **config['engine'],
        **config['ui'],
        **config['log'],
        today=time.strftime('%Y-%b-%d')
    ))


def start_engine(config, data_handler, execution_handler, portfolio, strategy, event_queue):
    """ Starts FincLab core """
    system = engine.Engine(
        config=config,
        data_handler=data_handler,
        execution_handler=execution_handler,
        portfolio=portfolio,
        strategy=strategy,
        event_queue=event_queue
    )
    system.run()


def start_ui(log_queue, config):
    """ Start the user interface """
    ui = CommandLineInterface(log_queue, config=config)
    curses.wrapper(ui.run)


if __name__ == "__main__":
    debug = False
    if debug:
        handler = logging.StreamHandler()
        listener = logging.handlers.QueueListener(log_queue, handler)
        listener.start()
    else:
        # Starts the user interface
        ui_process = mp.Process(target=start_ui, args=(log_queue, config))
        ui_process.start()
        # jobs.append(ui_process)

    # Program parameters
    initial_capital = float(config['general']['initial_capital'])
    heartbeat = float(config['engine']['heartbeat'])

    # Print welcome messages
    welcome_msgs(log_queue)

    # Starts the engine in a different process
    # Countdown 10 seconds
    for i in range(int(config['ui']['countdown']), 0, -1):
        logger.info('[Status]countdown:{}'.format(i))
        time.sleep(1)

    engine_process = mp.Process(target=start_engine,
                                args=(config, DataHandler, ExecutionHandler, Portfolio, Strategy, event_queue))
    engine_process.daemon = True
    engine_process.start()  # Launch engine as a separate Python program
    jobs.append(engine_process)

    start_time_ = time.time()

    # Wait for all processes to finish
    for job in jobs:
        job.join()

    logger.info("Engine completed suecessfully in {:.2f} seconds.".format(time.time() - start_time_))

    # formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')





