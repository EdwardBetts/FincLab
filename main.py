"""
    Project : FincLab

    Author : Peter Lee

Three components of the system are dynamic - it means that you could replace these components in the 'config.ini" file with other classes to override the default:

    strategy : class, default to "MovingAverageCrossover"
        Strategy transforms the data feeds into investment signals, which will be received by the Portfolio class to determine the appropriate order size. Different strategies are available in the strategy folder.

    data_handler : class, default to "HistoricDataHandler"
        DataHandler transforms time series data (or live streams) into periodic "bars" to feed the event-driven system. The "HistoricDataHandler" is suitable for backtesting.

    execution_handler: class, default to "SimulatedExecutionHandler"
        Execution_hanlder executes the orders generated by the Portfolio class. The default "SimulatedExecutionHandler" assumes Interactive Brokers' brokerage fee and ignores market microstructure issues such as slippage, fill ratios etc.
"""

import datetime as dt
from portfolio import Portfolio
import engine
from config import config
from logger import create_logger
import multiprocessing as mp
import time
import os
from dateutil import parser
from cli import CommandLineInterface

# Dynamically import the remaining system components
exec("from data.{module} import {module} as DataHandler".format(module=config["components"]["data_handler"]))
exec("from execution.{module} import {module} as ExecutionHandler".format(module=config["components"]["execution_handler"]))
exec("from strategy.{module} import {module} as Strategy".format(module=config["components"]["strategy"]))


def start_engine(symbol_list, data_handler, execution_handler, portfolio, strategy, event_queue, heartbeat, initial_capital, start_date):
    """ Starts FincLab core """
    system = engine.Engine(
        symbol_list=symbol_list,
        data_handler=DataHandler,
        execution_handler=ExecutionHandler,
        portfolio=Portfolio,
        strategy=Strategy,
        event_queue=event_queue,
        heartbeat=heartbeat,
        initial_capital=initial_capital,
        start_date=start_date
    )
    system.run()

def start_ui(log_queue, refresh_time=0.1):
    """ Start the user interface """
    ui = CommandLineInterface(log_queue, sleep_time=refresh_time)
    ui.run()

def main():
    # Program parameters
    initial_capital = float(config['general']['initial_capital'])
    heartbeat = float(config['general']['heartbeat'])
    start_date = parser.parse(config['general']['start_date'])
    symbol_list = config['general']['symbols'].split(' ')

    # Initialise environment vars
    event_queue = mp.Queue()
    log_queue = mp.Queue()
    logger = create_logger(log_queue)
    jobs = []

    logger.info("Now starting the engine.")

    # Starts the engine in a single process
    engine_process = mp.Process(target=start_engine,
                                args=(symbol_list, DataHandler, ExecutionHandler, Portfolio, Strategy, event_queue, heartbeat, initial_capital, start_date))
    engine_process.daemon = True
    engine_process.start()  # Launch engine as a separate Python program
    jobs.append(engine_process)

    # Starts the user interface
    ui_process = mp.Process(target=start_ui, args=(log_queue, float(config['ui']['refresh_time'])))
    ui_process.start()
    jobs.append(ui_process)

    start_time_ = time.time()

    # Wait for all processes to finish
    for j in jobs:
        j.join()

    print("Engine completed suecessfully and elapsed for {} seconds.".format(time.time() - start_time_))

if __name__ == "__main__":
    # formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    main()
